# Page-Rank

***Project still under Construction***

C++ Implementation of basic Page Rank Algorithm, using CSR Matrices

Compilation done with

> $ make

Execution run with the following command

> $ ./page-rank *input_file.txt*

Input files must be of the form:

> *<node 1 id>:\<first endorsed id>* followed by optional *,\<additional endorsed id>,<repeating ...>*
>
> *zero or more lines of the above format*

As example, Example.txt has been provided. Random graphs can be generated by running 

> $ ./graph *\<N>* > *output.txt*

Which the user can input into that page rank program

## How Page Rank works

Page Rank was developed between 1995 and 1998 by Larry Page and Sergey Brin, while conducting Research at Stanford University.

It would later become the initial source of Google's success.

The main insight of the algorithm comes from the following line: 

"A page is important if many important pages exclusively link to it" \(Dr. Yi Fang, SCU)

That is, Node 1's rank is a linear combination of all the nodes that link to it. The coefficients of this linear equation are either 0 \(if the node doesn't point to it), or 1/\(the total outgoing links from the node). In Example.txt, we see that Node 0 points to Node 2, and is itself pointed to by Nodes 2 and 4.

The upshot is that the rank of Node 0 is contributed to by Nodes 2 and 4, specifically one half the rank of Node 2 \(because Node 2 has 2 outgoing links) and the full rank of Node 4. Node 0 itself contributes to the rank of Node 2, lending it's full rank to the equation.

## How Page Rank really works

What we have then, is a system of equations of the classic form *v = Mv*, where the rank of each node in the graph is listed in the vector *v*, and the coefficients of each node contributing to each node is placed in matrix *M*. To actually get our hands on the values of *v*, we could solve for the eigenvector of matrix *M*, the one corresponding to the eigenvalue 1.

*\(1)v = Mv*

For **Big** Matrices however \(like the graph of the internet) this is practically infeasible. So we turn to an iterative method instead.

` while (||v(t+1) - v(t)|| < Îµ) v(t+1) = M * v(t); `

The values of *v* converge to stable values relatively quickly \(O\(log n)). This saves an extraordinary amount of time when computing the Page Rank of each node in the graph.

To start this off we need to assign values to the initial version of vector *v* that gets multiplied with *M*, *vo*. Note that an additional constraint, which turns out to be very useful for a variety of reasons that I won't get into, is that all the Page Ranks of a graph must sum to 1. Therefore, *vo* can be populated with equally sized contributions such that the reduction equals 1 i.e. 1 / N, where N is the amount of nodes in the graph.

## Some extra details

There's an issue during convergence when any one node links to itself exclusively, that results in diverging values with the above method. Messrs. Page and Brin solved this problem with a technique called teleporting, which is when the values of the vector resulting from *Mv* are 'jostled' by another vector, *I*, constructed in a manner similar to *v\(0)*. Both constructions *Mv* and *I* should be weighted to reflect their significance to the final calculation. 

` v = d * M * vo + (1 - d) * I `

Intuitively, we only need some small influence from the teleporting portion, so d tends to be fairly close to 1.
